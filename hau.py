import discord
from discord.ext import commands
import threading
import time
import re
import requests
import os
import random
import asyncio
import datetime
import json
import base64 
import aiohttp
import traceback
import shutil
import hashlib
from typing import Dict, Any
from threading import Thread
os.system("clear")

# Developer Zerfer w Gabi / 1-5-2025 
print("        B O T - M A D E - B Y - H A W U Jüí¢")
TOKEN = input("\033[31m [GABI BOT]\033[32m Vui l√≤ng nh·∫≠p token bot:\033[37m ") # Nh·∫≠p token bot discord
ADMIN_ID = int(input("\033[31m [GABI BOT]\033[32m Vui l√≤ng nh·∫≠p id admin bot:\033[37m ")) # Nh·∫≠p id admin bot
admins = []
IDADMIN_GOC = ADMIN_ID

intents = discord.Intents.default()
intents.messages = True
intents.message_content = True
bot = commands.Bot(command_prefix='.', intents=intents)

@bot.event
async def on_ready():
    print(f'\033[35m„Äã{bot.user}„Ää ƒë√£ b·∫≠t ch·∫ø ƒë·ªô hotwar 2025!')
   
#messenger task 
allowed_users = set()
treo_threads = {}
treo_start_times = {}
messenger_instances = {}
nhay_threads = {}
nhay_start_times = {}
chui_threads = {}
chui_start_times = {}
codelag_threads = {}
codelag_start_times = {}
so_threads = {}
so_start_times = {}
#discord task
start_time = datetime.datetime.utcnow()
UA_KIWI = [
    "Mozilla/5.0 (Linux; Android 11; RMX2185) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.6167.140 Mobile Safari/537.36",
    "Mozilla/5.0 (Linux; Android 12; Redmi Note 11) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.6099.129 Mobile Safari/537.36",
    "Mozilla/5.0 (Linux; Android 13; Pixel 6a) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.6261.68 Mobile Safari/537.36",
    "Mozilla/5.0 (Linux; Android 10; V2031) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.5938.60 Mobile Safari/537.36",
    "Mozilla/5.0 (Linux; Android 14; CPH2481) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.86 Mobile Safari/537.36"
]

UA_VIA = [
    "Mozilla/5.0 (Linux; Android 10; Redmi Note 8) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/108.0.0.0 Mobile Safari/537.36 Via/4.8.2",
    "Mozilla/5.0 (Linux; Android 11; V2109) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/112.0.5615.138 Mobile Safari/537.36 Via/4.9.0",
    "Mozilla/5.0 (Linux; Android 13; TECNO POVA 5) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/114.0.5735.134 Mobile Safari/537.36 Via/5.0.1",
    "Mozilla/5.0 (Linux; Android 12; Infinix X6710) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/115.0.5790.138 Mobile Safari/537.36 Via/5.2.0",
    "Mozilla/5.0 (Linux; Android 14; SM-A546E) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/122.0.6261.112 Mobile Safari/537.36 Via/5.3.1"
]

USER_AGENTS = UA_KIWI + UA_VIA

class Messenger:
    def __init__(self, cookie):
        self.cookie = cookie
        self.user_id = self.id_user()
        self.user_agent = random.choice(USER_AGENTS)
        self.fb_dtsg = None
        self.init_params()

    def id_user(self):
        try:
            c_user = re.search(r"c_user=(\d+)", self.cookie).group(1)
            return c_user
        except:
            raise Exception("Cookie kh√¥ng h·ª£p l·ªá")

    def init_params(self):
        headers = {
            'Cookie': self.cookie,
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.9,vi;q=0.8',
            'Sec-Fetch-Dest': 'document',
            'Sec-Fetch-Mode': 'navigate',
            'Sec-Fetch-Site': 'none',
            'Sec-Fetch-User': '?1',
            'Upgrade-Insecure-Requests': '1'
        }

        try:
            response = requests.get('https://www.facebook.com', headers=headers)
            fb_dtsg_match = re.search(r'"token":"(.*?)"', response.text)

            if not fb_dtsg_match:
                response = requests.get('https://mbasic.facebook.com', headers=headers)
                fb_dtsg_match = re.search(r'name="fb_dtsg" value="(.*?)"', response.text)

                if not fb_dtsg_match:
                    response = requests.get('https://m.facebook.com', headers=headers)
                    fb_dtsg_match = re.search(r'name="fb_dtsg" value="(.*?)"', response.text)

            if fb_dtsg_match:
                self.fb_dtsg = fb_dtsg_match.group(1)
            else:
                raise Exception("Kh√¥ng th·ªÉ l·∫•y ƒë∆∞·ª£c fb_dtsg")

        except Exception as e:
            raise Exception(f"L·ªói khi kh·ªüi t·∫°o tham s·ªë: {str(e)}")

    def gui_tn(self, recipient_id, message, max_retries=10):
        for attempt in range(max_retries):
            timestamp = int(time.time() * 1000)
            offline_threading_id = str(timestamp)
            message_id = str(timestamp)

            data = {
                'thread_fbid': recipient_id,
                'action_type': 'ma-type:user-generated-message',
                'body': message,
                'client': 'mercury',
                'author': f'fbid:{self.user_id}',
                'timestamp': timestamp,
                'source': 'source:chat:web',
                'offline_threading_id': offline_threading_id,
                'message_id': message_id,
                'ephemeral_ttl_mode': '',
                '__user': self.user_id,
                '__a': '1',
                '__req': '1b',
                '__rev': '1015919737',
                'fb_dtsg': self.fb_dtsg
            }

            headers = {
                'Cookie': self.cookie,
                'User-Agent': self.user_agent,
                'Accept': '*/*',
                'Accept-Language': 'vi-VN,vi;q=0.9,en-US;q=0.8,en;q=0.7',
                'Accept-Encoding': 'gzip, deflate, br',
                'Connection': 'keep-alive',
                'Content-Type': 'application/x-www-form-urlencoded',
                'Origin': 'https://www.facebook.com',
                'Referer': f'https://www.facebook.com/messages/t/{recipient_id}',
                'Host': 'www.facebook.com',
                'Sec-Fetch-Site': 'same-origin',
                'Sec-Fetch-Mode': 'cors',
                'Sec-Fetch-Dest': 'empty'
            }

            try:
                response = requests.post(
                    'https://www.facebook.com/messaging/send/',
                    data=data,
                    headers=headers
                )
                if response.status_code != 200:
                    return {
                        'success': False,
                        'error': 'HTTP_ERROR',
                        'error_description': f'Status code: {response.status_code}'
                    }

                if 'for (;;);' in response.text:
                    clean_text = response.text.replace('for (;;);', '')
                    try:
                        result = json.loads(clean_text)
                        if 'error' in result:
                            return {
                                'success': False,
                                'error': result.get('error'),
                                'error_description': result.get('errorDescription', 'Unknown error')
                            }
                        return {
                            'success': True,
                            'message_id': message_id,
                            'timestamp': timestamp
                        }
                    except json.JSONDecodeError:
                        pass

                return {
                    'success': True,
                    'message_id': message_id,
                    'timestamp': timestamp
                }
            except Exception as e:
                return {
                    'success': False,
                    'error': 'REQUEST_ERROR',
                    'error_description': str(e)
                }

def format_duration(seconds):
    m, s = divmod(int(seconds), 60)
    h, m = divmod(m, 60)
    d, h = divmod(h, 24)
    parts = []
    if d: parts.append(f"{d} ng√†y")
    if h: parts.append(f"{h} gi·ªù")
    if m: parts.append(f"{m} ph√∫t")
    if s or not parts: parts.append(f"{s} gi√¢y")
    return " ".join(parts)

def start_spam(user_id, idbox, cookie, message, delay):
    try:
        messenger = Messenger(cookie)
    except Exception as e:
        return f"L·ªói cookie: {str(e)}"

    def loop_send():
        while (user_id, idbox) in treo_threads:
            success = messenger.gui_tn(idbox, message)
            print(f"G·ª≠i Tin Nh·∫Øn {'Th√†nh C√¥ng' if success else 'Th·∫•t B·∫°i'}")
            time.sleep(delay)

    key = (user_id, idbox)
    thread = threading.Thread(target=loop_send)
    treo_threads[key] = thread
    treo_start_times[key] = time.time()
    messenger_instances[key] = messenger
    thread.start()
    return "ƒê√£ b·∫Øt ƒë·∫ßu g·ª≠i tin nh·∫Øn."
    
def start_nhay(user_id, idbox, cookie, delay):
    if not os.path.exists("nhay.txt"):
        return "Kh√¥ng t√¨m th·∫•y file nhay.txt."
    try:
        messenger = Messenger(cookie)
    except Exception as e:
        return f"L·ªói cookie: {str(e)}"

    with open("nhay.txt", "r", encoding="utf-8") as f:
        messages = [line.strip() for line in f if line.strip()]

    if not messages:
        return "File nhay.txt kh√¥ng c√≥ n·ªôi dung."

    def loop_nhay():
        index = 0
        while (user_id, idbox) in nhay_threads:
            message = messages[index % len(messages)]
            success = messenger.gui_tn(idbox, message)
            print(f"G·ª≠i tin nh·∫Øn {'Th√†nh c√¥ng' if success else 'Th·∫•t b·∫°i'}")
            time.sleep(delay)
            index += 1

    key = (user_id, idbox)
    thread = threading.Thread(target=loop_nhay)
    nhay_threads[key] = thread
    nhay_start_times[key] = time.time()
    thread.start()
    return "ƒê√£ b·∫Øt ƒë·∫ßu nh√¢y."
    
def start_chui(user_id, idbox, cookie, delay):
    if not os.path.exists("chui.txt"):
        return "Kh√¥ng t√¨m th·∫•y file chui.txt."
    try:
        messenger = Messenger(cookie)
    except Exception as e:
        return f"L·ªói cookie: {str(e)}"

    with open("chui.txt", "r", encoding="utf-8") as f:
        messages = [line.strip() for line in f if line.strip()]

    if not messages:
        return "File chui.txt kh√¥ng c√≥ n·ªôi dung."

    def loop_chui():
        index = 0
        while (user_id, idbox) in chui_threads:
            message = messages[index % len(messages)]
            success = messenger.gui_tn(idbox, message)
            print(f"G·ª≠i tin nh·∫Øn {'Th√†nh c√¥ng' if success else 'Th·∫•t b·∫°i'}")
            time.sleep(delay)
            index += 1

    key = (user_id, idbox)
    thread = threading.Thread(target=loop_chui)
    chui_threads[key] = thread
    chui_start_times[key] = time.time()
    thread.start()
    return "ƒê√£ b·∫Øt ƒë·∫ßu g·ª≠i tin nh·∫Øn."       
    
def start_codelag(user_id, idbox, cookie, delay):
    if not os.path.exists("codelag.txt"):
        return "Kh√¥ng t√¨m th·∫•y file codelag.txt."
    try:
        messenger = Messenger(cookie)
    except Exception as e:
        return f"L·ªói cookie: {str(e)}"

    with open("codelag.txt", "r", encoding="utf-8") as f:
        messages = [line.strip() for line in f if line.strip()]

    if not messages:
        return "File codelag.txt kh√¥ng c√≥ n·ªôi dung."

    def loop_codelag():
        index = 0
        while (user_id, idbox) in codelag_threads:
            message = messages[index % len(messages)]
            success = messenger.gui_tn(idbox, message)
            print(f"G·ª≠i tin nh·∫Øn {'Th√†nh c√¥ng' if success else 'Th·∫•t b·∫°i'}")
            time.sleep(delay)
            index += 1

    key = (user_id, idbox)
    thread = threading.Thread(target=loop_codelag)
    codelag_threads[key] = thread
    codelag_start_times[key] = time.time()
    thread.start()
    return "ƒê√£ b·∫Øt ƒë·∫ßu spam code lag."      

def start_so(user_id, idbox, cookie, delay):
    if not os.path.exists("so.txt"):
        return "Kh√¥ng t√¨m th·∫•y file so.txt."
    try:
        messenger = Messenger(cookie)
    except Exception as e:
        return f"L·ªói cookie: {str(e)}"

    with open("so.txt", "r", encoding="utf-8") as f:
        messages = [line.strip() for line in f if line.strip()]

    if not messages:
        return "File so.txt kh√¥ng c√≥ n·ªôi dung."

    def loop_so():
        index = 0
        while (user_id, idbox) in so_threads:
            message = messages[index % len(messages)]
            success = messenger.gui_tn(idbox, message)
            print(f"G·ª≠i tin nh·∫Øn {'Th√†nh c√¥ng' if success else 'Th·∫•t b·∫°i'}")
            time.sleep(delay)
            index += 1

    key = (user_id, idbox)
    thread = threading.Thread(target=loop_so)
    so_threads[key] = thread
    so_start_times[key] = time.time()
    thread.start()
    return "ƒê√£ b·∫Øt ƒë·∫ßu g·ª≠i tin nh·∫Øn."


    
# Ch·ª©c nƒÉng set ng√¥n treo mess
@bot.command()
async def setngonmess(ctx):
    if ctx.author.id not in admins and ctx.author.id != IDADMIN_GOC:
        return await ctx.send("**[GABI BOT]** B·∫°n ƒë√©o c√≥ quy·ªÅn s·ª≠ d·ª•ng bot n√†y.")
    if not ctx.message.attachments:
        return await ctx.send("**[GABI BOT]** Vui l√≤ng ƒë√≠nh k√®m file .txt.")
    attachment = ctx.message.attachments[0]
    if not attachment.filename.endswith(".txt"):
        return await ctx.send("**[GABI BOT]** Bot ch·ªâ ch·∫•p nh·∫≠n d·∫°ng file .txt")
    path = f"{ctx.author.id}_{attachment.filename}"
    await attachment.save(path)
    await ctx.send(f"**[GABI BOT]** ƒê√£ l∆∞u file th√†nh c√¥ng d∆∞·ªõi t√™n: `{path}`.")

# Ch·ª©c nƒÉng treo ng√¥n messenger
@bot.command()
async def ngonmess(ctx, idbox: str, cookie: str, filename: str, delay: int):
    if ctx.author.id not in admins and ctx.author.id != IDADMIN_GOC:
        return await ctx.send("**[GABI BOT]** B·∫°n ƒë√©o c√≥ quy·ªÅn s·ª≠ d·ª•ng bot n√†y.")
    filepath = f"{ctx.author.id}_{filename}"
    if not os.path.exists(filepath):
        return await ctx.send("**[GABI BOT]** Kh√¥ng t√¨m th·∫•y file ƒë√£ set.")
    with open(filepath, "r", encoding="utf-8") as f:
        message = f.read()
    result = start_spam(ctx.author.id, idbox, cookie, message, delay)
    await ctx.send(result)

# Ch·ª©c nƒÉng d·ª´ng treo ng√¥n messenger
@bot.command()
async def stopngonmess(ctx, idbox: str):
    removed = False
    keys_to_remove = [(uid, ib) for (uid, ib) in treo_threads if uid == ctx.author.id and ib == idbox]
    for key in keys_to_remove:
        treo_threads.pop(key)
        treo_start_times.pop(key)
        messenger_instances.pop(key)
        removed = True
    if removed:
        await ctx.send(f"**[GABI BOT]** ƒê√£ d·ª´ng c√°c tab treo v·ªõi idbox: `{idbox}`.")
    else:
        await ctx.send("**[GABI BOT]** Kh√¥ng c√≥ tab treo n√†o.")

# Ch·ª©c nƒÉng xem tab treo ng√¥n messenger
@bot.command()
async def tabngonmess(ctx):
    msg = "**Danh S√°ch Tab treo:**\n\n"
    count = 0
    for (uid, ib), start in treo_start_times.items():
        if uid == ctx.author.id:
            uptime = format_duration(time.time() - start)
            msg += f"**{ib}:** {uptime}\n"
            count += 1
    if count == 0:
        msg = "**[GABI BOT]** B·∫°n kh√¥ng c√≥ tab treo n√†o ƒëang ch·∫°y."
    await ctx.send(msg)

# Ch·ª©c nƒÉng th√™m admin bot
@bot.command()
async def addadmin(ctx, member: discord.Member):
    if ctx.author.id != IDADMIN_GOC:
        return await ctx.send("**[GABI BOT]** B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
    if member.id not in admins:
        admins.append(member.id)
        await ctx.send(f"**[GABI BOT]** ƒê√£ th√™m `{member.name}` v√†o danh s√°ch admin.")
    else:
        await ctx.send("**[GABI BOT]** Ng∆∞·ªùi n√†y ƒë√£ l√† admin r·ªìi.")

# Ch·ª©c nƒÉng x√≥a admin bot
@bot.command()
async def deladmin(ctx, member: discord.Member):
    if ctx.author.id != IDADMIN_GOC:
        return await ctx.send("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
    if member.id in admins and member.id != IDADMIN_GOC:
        admins.remove(member.id)
        await ctx.send(f"ƒê√£ xo√° `{member.name}` kh·ªèi danh s√°ch admin.")
                
        to_remove = [task_id for task_id, info in task_info.items() if info['admin_id'] == member.id]
        for task_id in to_remove:
            if task_id in running_tasks:
                running_tasks[task_id].cancel()
                del running_tasks[task_id]
            del task_info[task_id]
        await ctx.send(f"ƒê√£ d·ª´ng t·∫•t c·∫£ c√°c task do `{member.name}` t·∫°o.")
    else:
        await ctx.send("Kh√¥ng th·ªÉ xo√° admin g·ªëc ho·∫∑c ng∆∞·ªùi n√†y kh√¥ng ph·∫£i admin.")

# List admin bot
@bot.command()
async def listadmin(ctx):
    embed = discord.Embed(
        title="üìú Danh S√°ch Admin üìú",
        description="Danh s√°ch c√°c admin hi·ªán t·∫°i c·ªßa bot.",
        color=discord.Color.blue()
    )

    for admin_id in admins:
        try:
            user = await bot.fetch_user(admin_id)
            if admin_id == IDADMIN_GOC:
                embed.add_field(name=f"üí¢ {user.name}", value="(Admin G·ªëc)", inline=False)
            else:
                embed.add_field(name=f"üí¢ {user.name}", value="(Admin)", inline=False)
        except Exception:
            embed.add_field(name=f"üí¢ {admin_id}", value="(Kh√¥ng t√¨m ƒë∆∞·ª£c t√™n)", inline=False)

    await ctx.send(embed=embed)

# Ch·ª©c nƒÉng nh√¢y mess    
@bot.command()
async def nhaymess(ctx, idbox: str, cookie: str, delay: int):
    if ctx.author.id not in admins and ctx.author.id != IDADMIN_GOC:
        return await ctx.send("**[HAWUJüí¢]** B·∫°n ƒë√©o c√≥ quy·ªÅn s·ª≠ d·ª•ng bot n√†y.")
    result = start_nhay(ctx.author.id, idbox, cookie, delay)
    await ctx.send(result)

# Ch·ª©c nƒÉng d·ª´ng nh√¢y mess
@bot.command()
async def stopnhaymess(ctx, idbox: str):
    key = (ctx.author.id, idbox)
    if key in nhay_threads:
        nhay_threads.pop(key)
        nhay_start_times.pop(key)
        await ctx.send(f"**[HAWUJüí¢]** ƒê√£ d·ª´ng nh√¢y id box `{idbox}`.")
    else:
        await ctx.send("**[HAWUJüí¢]** Kh√¥ng c√≥ l·ªánh nh√¢y n√†o ƒëang ch·∫°y.")

# Ch·ª©c nƒÉng xem tab nh√¢y mess
@bot.command()
async def tabnhaymess(ctx):
    msg = "**Danh S√°ch Tab nh√¢y:**\n\n"
    count = 0
    for (uid, ib), start in nhay_start_times.items():
        if uid == ctx.author.id:
            uptime = format_duration(time.time() - start)
            msg += f"**{ib}:** {uptime}\n"
            count += 1
    if count == 0:
        msg = "**[GABI BOT]** B·∫°n kh√¥ng c√≥ tab nh√¢y n√†o ƒëang ch·∫°y."
    await ctx.send(msg) 

# Ch·ª©c nƒÉng ch·ª≠i ƒë·ªïng mess
@bot.command()
async def ideamess(ctx, idbox: str, cookie: str, delay: int):
    if ctx.author.id not in admins and ctx.author.id != IDADMIN_GOC:
        return await ctx.send("**[HAWUJüí¢]** B·∫°n ƒë√©o c√≥ quy·ªÅn s·ª≠ d·ª•ng bot n√†y.")
    result = start_chui(ctx.author.id, idbox, cookie, delay)
    await ctx.send(result)

# Ch·ª©c nƒÉng d·ª´ng ch·ª≠i ƒë·ªïng mess
@bot.command()
async def stopideamess(ctx, idbox: str):
    key = (ctx.author.id, idbox)
    if key in chui_threads:
        chui_threads.pop(key)
        chui_start_times.pop(key)
        await ctx.send(f"**[HAWUJüí¢]** ƒê√£ d·ª´ng ch·ª≠i id box `{idbox}`.")
    else:
        await ctx.send("**[HAWUJüí¢]** Kh√¥ng c√≥ l·ªánh ch·ª≠i n√†o ƒëang ch·∫°y.")

# Ch·ª©c nƒÉng xem tab ch·ª≠i mess
@bot.command()
async def tabideamess(ctx):
    msg = "**Danh S√°ch Tab:**\n\n"
    count = 0
    for (uid, ib), start in chui_start_times.items():
        if uid == ctx.author.id:
            uptime = format_duration(time.time() - start)
            msg += f"**{ib}:** {uptime}\n"
            count += 1
    if count == 0:
        msg = "**[HAWUJüí¢]** B·∫°n kh√¥ng c√≥ tab n√†o ƒëang ch·∫°y."
    await ctx.send(msg)

# Ch·ª©c nƒÉng spam codelag mess    
@bot.command()
async def codelag(ctx, idbox: str, cookie: str, delay: int):
    if ctx.author.id not in admins and ctx.author.id != IDADMIN_GOC:
        return await ctx.send("**[HAWUJüí¢]** B·∫°n ƒë√©o c√≥ quy·ªÅn s·ª≠ d·ª•ng bot n√†y.")
    result = start_codelag(ctx.author.id, idbox, cookie, delay)
    await ctx.send(result)

# Ch·ª©c nƒÉng d·ª´ng codelag mess             
@bot.command()
async def stopcodelag(ctx, idbox: str):
    key = (ctx.author.id, idbox)
    if key in codelag_threads:
        codelag_threads.pop(key)
        codelag_start_times.pop(key)
        await ctx.send(f"**[HAWUJüí¢]** ƒê√£ d·ª´ng spam code lag v√†o {idbox}.")
    else:
        await ctx.send("**[HAWUJüí¢]** Kh√¥ng c√≥ tab code lag n√†o ƒëang ch·∫°y.")

# Ch·ª©c nƒÉng xem tab codelag mess   
@bot.command()
async def tabcodelag(ctx):
    msg = "**Danh S√°ch Tab code lag:**\n\n"
    count = 0
    for (uid, ib), start in codelag_start_times.items():
        if uid == ctx.author.id:
            uptime = format_duration(time.time() - start)
            msg += f"**{ib}:** {uptime}\n"
            count += 1
    if count == 0:
        msg = "**[HAWUJüí¢]** B·∫°n kh√¥ng c√≥ tab code lag n√†o ƒëang ch·∫°y."
    await ctx.send(msg)

# Ch·ª©c nƒÉng th·∫£ s·ªõ mess
@bot.command()
async def so(ctx, idbox: str, cookie: str, delay: int):
    if ctx.author.id not in admins and ctx.author.id != IDADMIN_GOC:
        return await ctx.send("**[HAWUJüí¢]** B·∫°n ƒë√©o c√≥ quy·ªÅn s·ª≠ d·ª•ng bot n√†y.")
    result = start_so(ctx.author.id, idbox, cookie, delay)
    await ctx.send(result)

# Ch·ª©c nƒÉng d·ª´ng th·∫£ s·ªõ mess             
@bot.command()
async def stopso(ctx, idbox: str):
    key = (ctx.author.id, idbox)
    if key in so_threads:
        so_threads.pop(key)
        so_start_times.pop(key)
        await ctx.send(f"**[HAWUJüí¢]** ƒê√£ d·ª´ng th·∫£ s·ªõ v√†o {idbox}.")
    else:
        await ctx.send("**[HAWUJüí¢]** Kh√¥ng c√≥ tab s·ªõ n√†o ƒëang ch·∫°y.")

# Ch·ª©c nƒÉng xem tab s·ªõ mess   
@bot.command()
async def tabso(ctx):
    msg = "**Danh S√°ch Tab S·ªõ:**\n\n"
    count = 0
    for (uid, ib), start in so_start_times.items():
        if uid == ctx.author.id:
            uptime = format_duration(time.time() - start)
            msg += f"**{ib}:** {uptime}\n"
            count += 1
    if count == 0:
        msg = "**[HAWUJüí¢]** B·∫°n kh√¥ng c√≥ tab s·ªõ n√†o ƒëang ch·∫°y."
    await ctx.send(msg)
    
# Menu trang x·ªãn - code b·ªüi Ares
class SimpleMenu(discord.ui.View):
    def __init__(self):
        super().__init__()
        
        self.items = [ 
            ("‚öôÔ∏è .menu", "Xem c√°c ch·ª©c nƒÉng c·ªßa bot"),
            ("üí¢ .uptime", "Xem th·ªùi gian bot ho·∫°t ƒë·ªông"),
            ("üí¢ .ping", "Ki·ªÉm tra ƒë·ªô tr·ªÖ c·ªßa bot"),
            ("üí¢ .idkenh", "L·∫•y id k√™nh"),
            ("üí¢ .idsv", "L·∫•y id m√°y ch·ªß"),
            ("üí¢ .ngonmess [idbox] [cookie] [file.txt] [delay]", "Treo ng√¥n mess"),
            ("üí¢ .nhaymess [idbox] [cookie] [delay]", "Nh√¢y mess"),
            ("üí¢ .ideamess [idbox] [cookie] [delay]", "Ch·ª≠i ƒë·ªïng mess"),
            ("üí¢ .so [idbox] [cookie] [delay]", "Th·∫£ s·ªõ mess"),
            ("üí¢ .codelag [idbox] [cookie] [delay]", "Codelag mess"),
            ("‚õî .stop [L·ªánh war] [idbox]", "D·ª´ng l·ªánh war ƒëang ch·∫°y"),
            ("üì§ .setngonmess [G·ª≠i k√®m file .txt]", "Set ng√¥n cho treo mess"),
            ("üîí .addadmin [@user]", "Th√™m ng∆∞·ªùi d√πng l√†m admin"),
            ("üîì .deladmin [@user]", "X√≥a admin c·ªßa ng∆∞·ªùi d√πng"),
            ("üìÇ .tab [L·ªánh war]", "Xem c√°c task ƒëang ch·∫°y"),
            ("üí¢ .reo [Idbox] [Cookie] [Delay]","Nh√¢y Tag Mess"),
            ("üí¢ .stopreo [Idbox] [Cookie] [Delay]","Stop Nh√¢y Tag Mess"),
            ("üí¢ .nhaytop [Cookie] [Delay]","Nh√¢y B√†i Vi·∫øt"),
            ("üí¢ .stopnhaytop","Stop Nh√¢y B√†i Vi·∫øt"), 
            ("üí¢ .spam [n·ªôi dung]", "Spam n·ªôi dung"),
            ("üí¢ .nhay [id k√™nh] [delay]", "Nh√¢y discord nhi·ªÅu k√™nh"),
            ("üõë .stopspam", "D·ª´ng t·∫•t c·∫£ task spam"),
            ("üõë .stopnhay [id k√™nh]", "Kh√¥ng id k√™nh th√¨ d·ª´ng all task nh√¢y"),                                   
        ]
        
        self.per_page = 10
        self.pages = self.build_pages()
        self.total = len(self.pages)
        self.current = 0

    def build_pages(self):
        pages = []
        titles = [
    "üõ∏ TI·ªÜN √çCH DISCORD üõ∏",  
    "üß∏ CH·ª®C NƒÇNG MESSENGER üß∏",  
    "üåü CH·ª®C NƒÇNG DISCORD üåü" 
]
        
        for i in range(0, len(self.items), self.per_page):
            chunk = self.items[i:i+self.per_page]
            page_number = len(pages) + 1
            embed = discord.Embed(
                title=titles[page_number - 1] if page_number <= len(titles) else "Trang kh√°c",
                color=discord.Color.red()
            )
            for title, desc in chunk:
                embed.add_field(name=title, value=desc, inline=False)
            embed.set_footer(text=f"Trang {page_number}/{(len(self.items)-1)//self.per_page + 1}")
            pages.append(embed)
        
        return pages

    @discord.ui.button(label="‚¨ÖÔ∏è", style=discord.ButtonStyle.secondary)
    async def previous(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.current > 0:
            self.current -= 1
            await interaction.response.edit_message(embed=self.pages[self.current], view=self)

    @discord.ui.button(label="‚û°Ô∏è", style=discord.ButtonStyle.secondary)
    async def next(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.current < self.total - 1:
            self.current += 1
            await interaction.response.edit_message(embed=self.pages[self.current], view=self)

@bot.command()
async def menu(ctx):	
    view = SimpleMenu()
    msg = await ctx.send(embed=view.pages[0], view=view)
    await asyncio.sleep(300)
    try:
        await msg.delete()
    except discord.NotFound:
        pass

@bot.command()
async def ping(ctx):
    latency = bot.latency * 1000

    embed = discord.Embed(
        title="[HAWUJüí¢] Ping Bot",
        color=discord.Color.green()
    )

    embed.add_field(
        name="ƒê·ªô tr·ªÖ hi·ªán t·∫°i",
        value=f"> `{latency:.2f} ms`",
        inline=False
    )

    embed.set_footer(
        text=f"Y√™u c·∫ßu b·ªüi {ctx.author.display_name}",
        icon_url=ctx.author.avatar.url if ctx.author.avatar else None
    )

    await ctx.send(embed=embed)

@bot.command()
async def stopnhaytop(ctx):
    if ctx.author.id not in admins:
        return await ctx.send("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")

    admin_task_count = {}
    for task_id, info in task_info.items():
        if task_id.startswith("nhaytop_"):
            admin_id = info['admin_id']
            admin_task_count[admin_id] = admin_task_count.get(admin_id, 0) + 1

    if not admin_task_count:
        return await ctx.send("Hi·ªán kh√¥ng c√≥ task nhaytop n√†o ch·∫°y.")

    admin_list = list(admin_task_count.items())
    msg = "**Danh s√°ch admin ƒëang c√≥ task nhaytop:**\n"
    for i, (admin_id, count) in enumerate(admin_list, start=1):
        try:
            user = await bot.fetch_user(admin_id)
            msg += f"{i}. Admin {user.mention} ƒë√£ t·∫°o {count} task.\n"
        except:
            msg += f"{i}. Admin ID {admin_id} ƒë√£ t·∫°o {count} task.\n"

    msg += "\nNh·∫≠p s·ªë (v√≠ d·ª•: 1, 2) ƒë·ªÉ xem task c·ªßa admin t∆∞∆°ng ·ª©ng."
    await ctx.send(msg)

    def check(m):
        return m.author == ctx.author and m.channel == ctx.channel

    try:
        reply = await bot.wait_for('message', timeout=30.0, check=check)
        index = int(reply.content.strip()) - 1
        if index < 0 or index >= len(admin_list):
            return await ctx.send("S·ªë kh√¥ng h·ª£p l·ªá.")

        selected_admin_id = admin_list[index][0]
        if selected_admin_id != ctx.author.id:
            return await ctx.send("B·∫°n ch·ªâ c√≥ th·ªÉ d·ª´ng task do ch√≠nh m√¨nh t·∫°o.")

        tasks = []
        task_mapping = {}
        for task_id, info in task_info.items():
            if info['admin_id'] == selected_admin_id and task_id.startswith("nhaytop_"):
                post_id = info['post_id']
                group_id = info['group_id']
                start_time = info['start_time']
                delta = datetime.now() - datetime.fromtimestamp(start_time)
                formatted_time = str(delta).split('.')[0]
                task_index = len(tasks) + 1
                tasks.append(f"{task_index}. Group ID: {group_id}, Post ID: {post_id} (ch·∫°y ƒë∆∞·ª£c {formatted_time})")
                task_mapping[task_index] = task_id

        if not tasks:
            return await ctx.send("Admin n√†y kh√¥ng c√≥ task nhaytop n√†o.")

        await ctx.send("**Danh s√°ch task c·ªßa admin ƒë√£ ch·ªçn:**\n" + "\n".join(tasks) + "\n\nNh·∫≠p s·ªë task ƒë·ªÉ d·ª´ng (v√≠ d·ª•: 1, 2) ho·∫∑c 'all' ƒë·ªÉ d·ª´ng t·∫•t c·∫£.")

        reply = await bot.wait_for('message', timeout=30.0, check=check)
        user_input = reply.content.strip().lower()

        if user_input == "all":
            stopped_tasks = []
            for task_index, task_id in task_mapping.items():
                running_tasks[task_id].cancel()
                start_time = task_info[task_id]['start_time']
                delta = datetime.now() - datetime.fromtimestamp(start_time)
                formatted_time = str(delta).split('.')[0]
                group_id = task_info[task_id]['group_id']
                post_id = task_info[task_id]['post_id']
                stopped_tasks.append(f"Task Group ID: {group_id}, Post ID: {post_id} (ch·∫°y ƒë∆∞·ª£c {formatted_time})")
                del running_tasks[task_id]
                del task_info[task_id]
            await ctx.send(f"ƒê√£ d·ª´ng t·∫•t c·∫£ task:\n" + "\n".join(stopped_tasks))
        else:
            task_index = int(user_input)
            if task_index not in task_mapping:
                return await ctx.send("S·ªë task kh√¥ng h·ª£p l·ªá.")
            
            task_id = task_mapping[task_index]
            running_tasks[task_id].cancel()
            start_time = task_info[task_id]['start_time']
            delta = datetime.now() - datetime.fromtimestamp(start_time)
            formatted_time = str(delta).split('.')[0]
            group_id = task_info[task_id]['group_id']
            post_id = task_info[task_id]['post_id']
            del running_tasks[task_id]
            del task_info[task_id]
            await ctx.send(f"ƒê√£ d·ª´ng task Group ID: `{group_id}`, Post ID: `{post_id}` (ch·∫°y ƒë∆∞·ª£c {formatted_time}).")

    except asyncio.TimeoutError:
        await ctx.send("H·∫øt th·ªùi gian ch·ªù, vui l√≤ng th·ª≠ l·∫°i sau.")
    except ValueError:
        await ctx.send("Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá ho·∫∑c 'all'.")
    except Exception as e:
        await ctx.send(f"ƒê√£ x·∫£y ra l·ªói: {str(e)}")

@bot.command()
async def uptime(ctx):
    now = datetime.datetime.utcnow()
    delta = now - start_time
    total_seconds = int(delta.total_seconds())

    seconds = total_seconds % 60
    minutes = (total_seconds // 60) % 60
    hours = (total_seconds // 3600) % 24
    days = (total_seconds // 86400) % 7
    weeks = (total_seconds // 604800) % 4
    months = (total_seconds // 2592000) % 12  
    years = total_seconds // 31536000          

    embed = discord.Embed(
        title="[GABI BOT] Uptime Bot",
        color=discord.Color.blue()
    )

    embed.add_field(name="Th·ªùi gian ho·∫°t ƒë·ªông", value="\n".join([
        f"> `{years}` nƒÉm",
        f"> `{months}` th√°ng",
        f"> `{weeks}` tu·∫ßn",
        f"> `{days}` ng√†y",
        f"> `{hours}` gi·ªù",
        f"> `{minutes}` ph√∫t",
        f"> `{seconds}` gi√¢y",
    ]), inline=False)

    embed.set_footer(
        text=f"Y√™u c·∫ßu b·ªüi {ctx.author.display_name}",
        icon_url=ctx.author.avatar.url if ctx.author.avatar else None
    )

    await ctx.send(embed=embed)

# l·∫•y id k√™nh v√† id server
@bot.command()
async def idkenh(ctx):
    if ctx.author.id not in admins and ctx.author.id != IDADMIN_GOC:
        return await ctx.send("**[GABI BOT]** B·∫°n ƒë√©o c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
    await ctx.send(f'Channel ID: {ctx.channel.id}')
@bot.command()
async def idsv(ctx):
    if ctx.author.id not in admins and ctx.author.id != IDADMIN_GOC:
        return await ctx.send("**[GABI BOT]** B·∫°n ƒë√©o c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")    
    await ctx.send(f'Server ID: {ctx.guild.id}')

spamming_tasks = []

@bot.command()
async def spam(ctx, ids: str, delay: int, *, content: str):
    if ctx.author.id not in admins and ctx.author.id != IDADMIN_GOC:
        return await ctx.send("**[GABI BOT]** B·∫°n ƒë√©o c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
    
    channel_ids = [int(id.strip()) for id in ids.split(",")]

    async def spam_channel(channel_id):
        try:
            channel = bot.get_channel(channel_id)
            if channel:
                while True:
                    await channel.send(content)
                    await asyncio.sleep(delay)
        except Exception as e:
            print(f"L·ªói khi spam k√™nh {channel_id}: {e}")

    for cid in channel_ids:
        task = bot.loop.create_task(spam_channel(cid))
        spamming_tasks.append(task)

    await ctx.send("**[GABI BOT]** ƒê√£ b·∫Øt ƒë·∫ßu spam.")

@bot.command()
async def stopspam(ctx):
    if ctx.author.id not in admins and ctx.author.id != IDADMIN_GOC:
        return await ctx.send("B·∫°n ƒë√©o c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
    
    for task in spamming_tasks:
        task.cancel()
    spamming_tasks.clear()
    await ctx.send("**[GABI BOT]** ƒê√£ d·ª´ng t·∫•t c·∫£ spam.")

nhay_tasks = {}

@bot.command()
async def nhay(ctx, channel_ids: str, delay: int):
    channels = [bot.get_channel(int(channel_id.strip())) for channel_id in channel_ids.split(",")]

    try:
        with open("nhay.txt", "r", encoding="utf-8") as file:
            lines = file.readlines()
    except FileNotFoundError:
        return await ctx.send("**[GABI BOT]** Kh√¥ng t√¨m th·∫•y file nhay.txt.")

    async def nhay_in_channel(channel):
        while True:
            for line in lines:
                await channel.send(line.strip())
                await asyncio.sleep(delay)

    for channel in channels:
        if channel.id not in nhay_tasks:
            nhay_task = bot.loop.create_task(nhay_in_channel(channel))
            nhay_tasks[channel.id] = nhay_task
        else:
            await ctx.send(f"**[GABI BOT]** ƒêang c√≥ task nhay cho k√™nh {channel.name}.")

    await ctx.send(f"**[GABI BOT]** ƒê√£ b·∫Øt ƒë·∫ßu nhay cho c√°c k√™nh: {', '.join([channel.name for channel in channels])}.")
    
    
@bot.command()
async def reo(ctx, id_box: str, cookie: str, delay: float):
    if ctx.author.id not in admins:
        return await ctx.send("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
    
    # Ki·ªÉm tra file nhay.txt
    file_path = "nhay.txt"
    if not os.path.exists(file_path):
        return await ctx.send("File `nhay.txt` kh√¥ng t·ªìn t·∫°i.")

    # Y√™u c·∫ßu nh·∫≠p ID ng∆∞·ªùi c·∫ßn tag
    await ctx.send("Vui l√≤ng nh·∫≠p ID ng∆∞·ªùi c·∫ßn tag:")

    def check(m):
        return m.author == ctx.author and m.channel == ctx.channel

    try:
        msg = await bot.wait_for('message', timeout=30.0, check=check)
        tagged_id = msg.content.strip()
        if not tagged_id.isdigit():
            return await ctx.send("ID tag ph·∫£i l√† s·ªë h·ª£p l·ªá.")
    except asyncio.TimeoutError:
        return await ctx.send("H·∫øt th·ªùi gian ch·ªù nh·∫≠p ID tag.")

    # Ki·ªÉm tra cookie v√† l·∫•y fb_dtsg, jazoest
    fb_dtsg, jazoest = get_fb_dtsg_jazoest(cookie, id_box)
    if not fb_dtsg:
        return await ctx.send("Cookie kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng l·∫•y ƒë∆∞·ª£c th√¥ng tin.")

    # ƒê·ªçc n·ªôi dung t·ª´ nhay.txt
    with open(file_path, 'r', encoding='utf-8') as f:
        lines = [line.strip() for line in f if line.strip()]
    if not lines:
        return await ctx.send("File `nhay.txt` r·ªóng, vui l√≤ng th√™m n·ªôi dung.")

    # T·∫°o task ID duy nh·∫•t
    task_id = f"reo_{id_box}_{time.time()}"
    
    async def spam_reo():
        index = 0
        while True:
            # T·∫°o n·ªôi dung tin nh·∫Øn v·ªõi tag ng∆∞·ªùi d√πng
            content = f"{lines[index]} @[tagged_id:0]"
            success = send_message(id_box, fb_dtsg, jazoest, cookie, content)
            if success:
                print(f"[+] ƒê√£ g·ª≠i tin nh·∫Øn v·ªõi tag v√†o box {id_box}: {content}")
            else:
                print(f"[!] G·ª≠i tin nh·∫Øn th·∫•t b·∫°i v√†o box {id_box}")
            index = (index + 1) % len(lines)
            await asyncio.sleep(delay)

    # T·∫°o v√† l∆∞u task
    task = asyncio.create_task(spam_reo())
    running_tasks[task_id] = task
    task_info[task_id] = {
        'admin_id': ctx.author.id,
        'start_time': time.time(),
        'tagged_id': tagged_id,
        'box_id': id_box
    }
    await ctx.send(f"ƒê√£ b·∫Øt ƒë·∫ßu `reo` v√†o box `{id_box}` v√† tag ID `{tagged_id}` v·ªõi t·ªëc ƒë·ªô `{delay}` gi√¢y.")

@bot.command()
async def stopreo(ctx, id_box: str):
    if ctx.author.id not in admins:
        return await ctx.send("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
    
    # T√¨m t·∫•t c·∫£ task li√™n quan ƒë·∫øn id_box
    tasks_to_stop = [task_id for task_id in running_tasks if task_id.startswith(f"reo_{id_box}")]
    
    if not tasks_to_stop:
        return await ctx.send(f"Kh√¥ng c√≥ task `reo` n√†o ƒëang ch·∫°y cho box `{id_box}`.")
    
    for task_id in tasks_to_stop:
        if task_info.get(task_id, {}).get('admin_id') == ctx.author.id or ctx.author.id == IDADMIN_GOC:
            running_tasks[task_id].cancel()
            tagged_id = task_info[task_id].get('tagged_id', 'Unknown')
            del running_tasks[task_id]
            del task_info[task_id]
            await ctx.send(f"ƒê√£ d·ª´ng l·ªánh `reo` trong box `{id_box}` v·ªõi tag ID `{tagged_id}`.")
        else:
            await ctx.send(f"B·∫°n kh√¥ng c√≥ quy·ªÅn d·ª´ng task `{task_id}`.")
            

@bot.command()
async def stopnhay(ctx, channel_id: str = None):
    if channel_id:
        channel = bot.get_channel(int(channel_id))
        if channel and channel.id in nhay_tasks:
            nhay_tasks[channel.id].cancel()
            del nhay_tasks[channel.id]
            await ctx.send(f"**[GABI BOT]** ƒê√£ d·ª´ng nhay cho k√™nh {channel.name}.")
        else:
            await ctx.send("**[GABI BOT]** Kh√¥ng t√¨m th·∫•y task nhay cho k√™nh n√†y.")
    else:
        for task in nhay_tasks.values():
            task.cancel()
        nhay_tasks.clear()
        await ctx.send("**[GABI BOT]** ƒê√£ d·ª´ng t·∫•t c·∫£ c√°c task nhay.")

def get_guid():
    section_length = int(time.time() * 1000)
    
    def replace_func(c):
        nonlocal section_length
        r = (section_length + random.randint(0, 15)) % 16
        section_length //= 16
        return hex(r if c == "x" else (r & 7) | 8)[2:]

    return "".join(replace_func(c) if c in "xy" else c for c in "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx")

def normalize_cookie(cookie, domain='www.facebook.com'):
    headers = {
        'Cookie': cookie,
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (like Gecko) Chrome/122.0.0.0 Safari/537.36'
    }
    try:
        response = requests.get(f'https://{domain}/', headers=headers, timeout=10)
        if response.status_code == 200:
            set_cookie = response.headers.get('Set-Cookie', '')
            new_tokens = re.findall(r'([a-zA-Z0-9_-]+)=[^;]+', set_cookie)
            cookie_dict = dict(re.findall(r'([a-zA-Z0-9_-]+)=([^;]+)', cookie))
            for token in new_tokens:
                if token not in cookie_dict:
                    cookie_dict[token] = ''
            return ';'.join(f'{k}={v}' for k, v in cookie_dict.items() if v)
    except:
        pass
    return cookie
    
def get_uid_fbdtsg(ck):
    try:
        headers = {
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
            'Accept-Encoding': 'gzip, deflate',
            'Accept-Language': 'en-US,en;q=0.9,vi;q=0.8',
            'Connection': 'keep-alive',
            'Cookie': ck,
            'Host': 'www.facebook.com',
            'Sec-Fetch-Dest': 'document',
            'Sec-Fetch-Mode': 'navigate',
            'Sec-Fetch-Site': 'none',
            'Sec-Fetch-User': '?1',
            'Upgrade-Insecure-Requests': '1',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (like Gecko) Chrome/122.0.0.0 Safari/537.36'
        }
        
        try:
            response = requests.get('https://www.facebook.com/', headers=headers)
            
            if response.status_code != 200:
                print(f"Status Code >> {response.status_code}")
                return None, None, None, None, None, None
                
            html_content = response.text
            
            user_id = None
            fb_dtsg = None
            jazoest = None
            
            script_tags = re.findall(r'<script id="__eqmc" type="application/json[^>]*>(.*?)</script>', html_content)
            for script in script_tags:
                try:
                    json_data = json.loads(script)
                    if 'u' in json_data:
                        user_param = re.search(r'__user=(\d+)', json_data['u'])
                        if user_param:
                            user_id = user_param.group(1)
                            break
                except:
                    continue
            
            fb_dtsg_match = re.search(r'"f":"([^"]+)"', html_content)
            if fb_dtsg_match:
                fb_dtsg = fb_dtsg_match.group(1)
            
            jazoest_match = re.search(r'jazoest=(\d+)', html_content)
            if jazoest_match:
                jazoest = jazoest_match.group(1)
            
            revision_match = re.search(r'"server_revision":(\d+),"client_revision":(\d+)', html_content)
            rev = revision_match.group(1) if revision_match else ""
            
            a_match = re.search(r'__a=(\d+)', html_content)
            a = a_match.group(1) if a_match else "1"
            
            req = "1b"
                
            return user_id, fb_dtsg, rev, req, a, jazoest
                
        except requests.exceptions.RequestException as e:
            print(f"L·ªói K·∫øt N·ªëi Khi L·∫•y UID/FB_DTSG: {e}")
            return get_uid_fbdtsg(ck)
            
    except Exception as e:
        print(f"L·ªói: {e}")
        return None, None, None, None, None, None

def get_info(uid: str, cookie: str, fb_dtsg: str, a: str, req: str, rev: str) -> Dict[str, Any]:
    try:
        form = {
            "ids[0]": uid,
            "fb_dtsg": fb_dtsg,
            "__a": a,
            "__req": req,
            "__rev": rev
        }
        
        headers = {
            'Accept': '*/*',
            'Accept-Language': 'en-US,en;q=0.9,vi;q=0.8',
            'Connection': 'keep-alive',
            'Content-Type': 'application/x-www-form-urlencoded',
            'Cookie': cookie,
            'Origin': 'https://www.facebook.com',
            'Referer': 'https://www.facebook.com/',
            'Sec-Fetch-Dest': 'empty',
            'Sec-Fetch-Mode': 'cors',
            'Sec-Fetch-Site': 'same-origin',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (like Gecko) Chrome/122.0.0.0 Safari/537.36'
        }
        
        response = requests.post(
            "https://www.facebook.com/chat/user_info/",
            headers=headers,
            data=form
        )
        
        if response.status_code != 200:
            return {"error": f"L·ªói K·∫øt N·ªëi: {response.status_code}"}
        
        try:
            text_response = response.text
            if text_response.startswith("for (;;);"):
                text_response = text_response[9:]
            
            res_data = json.loads(text_response)
            
            if "error" in res_data:
                return {"error": res_data.get("error")}
            
            if "payload" in res_data and "profiles" in res_data["payload"]:
                return format_data(res_data["payload"]["profiles"])
            else:
                return {"error": f"Kh√¥ng T√¨m Th·∫•y Th√¥ng Tin C·ªßa {uid}"}
                
        except json.JSONDecodeError:
            return {"error": "L·ªói Khi Ph√¢n T√≠ch JSON"}
            
    except Exception as e:
        print(f"L·ªói Khi Get Info: {e}")
        return {"error": str(e)}

def format_data(profiles):
    if not profiles:
        return {"error": "Kh√¥ng C√≥ Data"}
    
    first_profile_id = next(iter(profiles))
    profile = profiles[first_profile_id]
    
    return {
        "id": first_profile_id,
        "name": profile.get("name", ""),
        "url": profile.get("url", ""),
        "thumbSrc": profile.get("thumbSrc", ""),
        "gender": profile.get("gender", "")
    }

def cmt_gr_pst(cookie, grid, postIDD, ctn, user_id, fb_dtsg, rev, req, a, jazoest, uidtag=None, nametag=None):
    try:
        if not all([user_id, fb_dtsg, jazoest]):
            print("Thi·∫øu user_id, fb_dtsg ho·∫∑c jazoest")
            return False
        client_mutation_id = str(round(random.random() * 19))
        session_id = get_guid()  
        crt_time = int(time.time() * 1000)
        
        variables = {
            "feedLocation": "DEDICATED_COMMENTING_SURFACE",
            "feedbackSource": 110,
            "groupID": grid,
            "input": {
                "client_mutation_id": client_mutation_id,
                "actor_id": user_id,
                "attachments": None,
                "feedback_id": pstid_enc,
                "formatting_style": None,
                "message": {
                    "ranges": [],
                    "text": ctn
                },
                "attribution_id_v2": f"SearchCometGlobalSearchDefaultTabRoot.react,comet.search_results.default_tab,tap_search_bar,{crt_time},775647,391724414624676,,",
                "vod_video_timestamp": None,
                "is_tracking_encrypted": True,
                "tracking": [],
                "feedback_source": "DEDICATED_COMMENTING_SURFACE",
                "session_id": session_id
            },
            "inviteShortLinkKey": None,
            "renderLocation": None,
            "scale": 3,
            "useDefaultActor": False,
            "focusCommentID": None,
            "__relay_internal__pv__IsWorkUserrelayprovider": False
        }
        
        if uidtag and nametag:
            name_position = ctn.find(nametag)
            if name_position != -1:
                variables["input"]["message"]["ranges"] = [
                    {
                        "entity": {
                            "id": uidtag
                        },
                        "length": len(nametag),
                        "offset": name_position
                    }
                ]
            
        payload = {
            'av': user_id,
            '__crn': 'comet.fbweb.CometGroupDiscussionRoute',
            'fb_dtsg': fb_dtsg,
            'jazoest': jazoest,
            'fb_api_caller_class': 'RelayModern',
            'fb_api_req_friendly_name': 'useCometUFICreateCommentMutation',
            'variables': json.dumps(variables),
            'server_timestamps': 'true',
            'doc_id': '24323081780615819'
        }
        
        headers = {
            'Accept': '*/*',
            'Accept-Encoding': 'identity',
            'Connection': 'keep-alive',
            'Content-Type': 'application/x-www-form-urlencoded',
            'Cookie': cookie,
            'Origin': 'https://www.facebook.com',
            'Referer': f'https://www.facebook.com/groups/{grid}',
            'User-Agent': 'python-http/0.27.0'
        }
        
        response = requests.post('https://www.facebook.com/api/graphql', data=payload, headers=headers)
        print(f"M√£ tr·∫°ng th√°i cho b√†i {postIDD}: {response.status_code}")
        print(f"Ph·∫£n h·ªìi: {response.text[:500]}...") 
        
        if response.status_code == 200:
            try:
                json_response = response.json()
                if 'errors' in json_response:
                    print(f"L·ªói GraphQL: {json_response['errors']}")
                    return False
                if 'data' in json_response and 'comment_create' in json_response['data']:
                    print("B√¨nh lu·∫≠n ƒë√£ ƒë∆∞·ª£c ƒëƒÉng")
                    return True
                print("Kh√¥ng t√¨m th·∫•y comment_create trong ph·∫£n h·ªìi")
                return False
            except ValueError:
                print("Ph·∫£n h·ªìi JSON kh√¥ng h·ª£p l·ªá")
                return False
        else:
            return False
    except Exception as e:
        print(f"L·ªói khi g·ª≠i b√¨nh lu·∫≠n: {e}")
        return False

def extract_post_group_id(post_link):
    post_match = re.search(r'facebook\.com/.+/permalink/(\d+)', post_link)
    group_match = re.search(r'facebook\.com/groups/(\d+)', post_link)
    if not post_match or not group_match:
        return None, None
    return post_match.group(1), group_match.group(1)

@bot.command()
async def nhaytop(ctx, cookie: str, delay: float):
    if ctx.author.id not in admins and ctx.author.id != IDADMIN_GOC:
        await ctx.send("**[GABI BOT]** B·∫°n ƒë√©o c√≥ quy·ªÅn s·ª≠ d·ª•ng bot n√†y.")
        return

    path = "nhay.txt"
    if not os.path.exists(path):
        await ctx.send("Kh√¥ng t√¨m th·∫•y file `nhay.txt`.")
        return

    await ctx.send("Vui l√≤ng nh·∫≠p link b√†i vi·∫øt (v√≠ d·ª•: https://facebook.com/groups/123/permalink/456):")
    def check(m):
        return m.author == ctx.author and m.channel == ctx.channel
    try:
        msg = await bot.wait_for('message', timeout=30.0, check=check)
        post_link = msg.content.strip()
    except asyncio.TimeoutError:
        await ctx.send("H·∫øt th·ªùi gian ch·ªù nh·∫≠p link b√†i vi·∫øt.")
        return

    post_id, group_id = extract_post_group_id(post_link)
    if not post_id or not group_id:
        await ctx.send("Link b√†i vi·∫øt kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng t√¨m ƒë∆∞·ª£c group_id.")
        return

    cookie = normalize_cookie(cookie)
    
    user_id, fb_dtsg, rev, req, a, jazoest = get_uid_fbdtsg(cookie)
    if not user_id or not fb_dtsg or not jazoest:
        await ctx.send("Cookie kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng l·∫•y ƒë∆∞·ª£c th√¥ng tin.")
        return

    with open(path, 'r', encoding='utf-8') as f:
        lines = [line.strip() for line in f if line.strip()]
    if not lines:
        await ctx.send("File `nhay.txt` r·ªóng.")
        return

    task_id = f"nhaytop_{post_id}_{time.time()}"
    
    async def loop_nhaytop():
        index = 0
        while True:
            message = lines[index]
            success = cmt_gr_pst(cookie, group_id, post_id, message, user_id, fb_dtsg, rev, req, a, jazoest)
            if success:
                print(f"[+] ƒê√£ g·ª≠i b√¨nh lu·∫≠n v√†o b√†i {post_id}: {message}")  
            else:
                print(f"[!] G·ª≠i b√¨nh lu·∫≠n th·∫•t b·∫°i v√†o b√†i {post_id}")  
            index = (index + 1) % len(lines)
            await asyncio.sleep(delay)

    task = asyncio.create_task(loop_nhaytop())
    running_tasks[task_id] = task
    task_info[task_id] = {
        'admin_id': ctx.author.id,
        'start_time': time.time(),
        'post_id': post_id,
        'group_id': group_id
    }
    await ctx.send(f"ƒê√£ b·∫Øt ƒë·∫ßu `nhaytop` v√†o b√†i vi·∫øt `{post_id}` v·ªõi t·ªëc ƒë·ªô `{delay}` gi√¢y.")
bot.run(TOKEN)